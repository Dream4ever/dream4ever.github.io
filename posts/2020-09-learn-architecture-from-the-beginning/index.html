<!DOCTYPE html>
<html lang="en-us" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="何伟" />
	
	
	
	<title>《从0开始学架构》学习笔记 ｜ 岁月留痕</title>
	
    
    
    <meta name="description" content="课程链接：https://time.geekbang.org/column/intro/81 第二遍阅读时，选出每篇文章的优质留言 01 | 架构到底是指什么？ 课程链接：https://time.geekban" />
    

    

	
    
    <link rel="shortcut icon" href="https://www.hewei.in/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://www.hewei.in/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://www.hewei.in/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://www.hewei.in/css/highlight.css" />

    
    
</head>

<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://www.hewei.in/">
                    <span>岁月留痕</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title"></p>
            <div class="my_socials">
                
                
                <a href="https://github.com/Dream4ever" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                <a href="https://www.hewei.in/index.xml" type="application/rss+xml" title="rss" target="_blank"><i
                        class="ri-rss-fill"></i></a>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2020-09-learn-architecture-from-the-beginning/'>《从0开始学架构》学习笔记</a></h2>
                        <span class="date">2020.09.30</span>
                    </div>
                    <div class="post_content markdown"><ul>
<li>课程链接：<a href="https://time.geekbang.org/column/intro/81">https://time.geekbang.org/column/intro/81</a></li>
<li>第二遍阅读时，选出每篇文章的优质留言</li>
</ul>
<hr>
<h2 id="01--架构到底是指什么">01 | 架构到底是指什么？</h2>
<ul>
<li>课程链接：<a href="https://time.geekbang.org/column/article/6458">https://time.geekbang.org/column/article/6458</a></li>
</ul>
<h3 id="系统与子系统">系统与子系统</h3>
<p>系统：</p>
<ul>
<li>由一群<strong>有关联的个体</strong>（如汽车的发动机、底盘、轮胎等各部分），</li>
<li>根据<strong>某种规则运作</strong>（如发动机产生动力，变速器和传动轴传输动力），</li>
<li>能完成个别元件不能单独完成的工作的<strong>群体</strong>（系统不是个体能力的简单加和，而是产生新的能力，比如汽车各部分组合起来之后，才能载重前进）。</li>
</ul>
<p>子系统和系统的定义其实一样，只是观察的角度不同，一个系统可能是另一个更大系统的子系统。</p>
<ul>
<li>比如微信本身是一个大系统，包含聊天、登录、支付、朋友圈等子系统。</li>
<li>朋友圈这个系统又进一步包含动态、评论、点赞等子系统。</li>
<li>评论这个系统又进一步包含防刷子系统、审核子系统、发布子系统、存储子系统。</li>
<li>评论审核子系统不再包含<strong>业务意义上</strong>的子系统，而是包括各个模块或组件，这些模块或组件可能也是另一个维度上的系统。比如 MySQL、Redis 是存储系统，但不是业务子系统。</li>
</ul>
<h3 id="模块与组件">模块与组件</h3>
<p>模块和组件其实都是系统的最够深，只是从不同的角度拆分系统而已。</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>从<strong>逻辑</strong>的角度拆分系统</td>
<td>从<strong>物理</strong>的角度拆分系统</td>
</tr>
<tr>
<td>主要为了职责分离</td>
<td>主要为了单元复用</td>
</tr>
</tbody>
</table>
<p>比如一个常见的学生信息管理系统：</p>
<ul>
<li>从模块（逻辑）的角度来拆分，可以分为：登录注册模块、个人信息模块、个人成绩模块。</li>
<li>从组件（物理）的角度来拆分，可以分为：Nginx、Web 服务器、MySQL。</li>
</ul>
<h3 id="框架与架构">框架与架构</h3>
<p>框架：软件组件的规范，比如 MVC、MVP、MVVM、J2EE 等；或者按照规范做出来的、提供基础功能的产品，比如 Spring MVC、Spring JPA 等。</p>
<p>架构：软件系统的<strong>顶层结构</strong>。</p>
<ul>
<li>比如对于由一群关联个体组成的系统，架构用来明确系统包含哪些个体。</li>
<li>系统中的个体各自按照规则运作，架构用来明确个体运作和互相协作的规则。</li>
<li>用顶层结构来指代架构，可以避免将系统架构和子系统架构相混淆。</li>
</ul>
<p>要区分两者的不同，再用上面的学生信息管理系统举例：</p>
<ul>
<li>从业务逻辑角度分解，其架构可以分为：登录注册模块、个人信息模块、个人成绩模块。</li>
<li>从物理部署角度分解，其架构可以分为：Nginx、Web 服务器、MySQL。</li>
<li>从开发规范角度分解，该系统可以用标准的 MVC 框架来开发，因此架构又变成了 MVC 架构。</li>
</ul>
<h3 id="todo">TODO</h3>
<p>分析公司业务的架构、系统、模块、组件。</p>
<hr>
<h2 id="02--架构设计的历史背景">02 | 架构设计的历史背景</h2>
<ul>
<li>课程链接：<a href="https://time.geekbang.org/column/article/6463">https://time.geekbang.org/column/article/6463</a></li>
</ul>
<p>最初的机器语言：太难写、太难读、太难改</p>
<p>→ 汇编语言：易读性显著提升，但编写还是很复杂，且不同 CPU 的汇编指令和结构各不相同</p>
<p>→ 高级语言：无需关注机器底层的结构和逻辑，只需关注具体问题和业务，且可以编译为适合各种 CPU 指令的机器语言</p>
<p>→ 第一次软件危机：1960/1970年代，软件“逻辑”异常复杂：IBM 的 System/360 操作系统开发，投入巨大，进度不断延迟，质量也得不到保障</p>
<p>→ 提出软件工程、结构化程序设计（面向过程：自顶向下、逐步细化、模块化），用于解决软件危机</p>
<p>→ 第二次软件危机：1980年代，软件“扩展”异常复杂：硬件飞速发展，业务需求越发复杂，编程应用领域越发广泛</p>
<p>→ 面向对象思想开始流行</p>
<p>→ 软件系统越来越复杂：1990年代，随着软件系统规模的增加，算法和数据结构不再是主要的设计问题，软件架构才是主要的设计问题</p>
<hr>
<h2 id="03--架构设计的目的">03 | 架构设计的目的</h2>
<ul>
<li>课程链接：<a href="https://time.geekbang.org/column/article/6463">https://time.geekbang.org/column/article/6472</a></li>
</ul>
<p>架构设计的主要目的：解决软件系统复杂度带来的问题。</p>
<h3 id="常见误区">常见误区</h3>
<ul>
<li>
<p>Q: 需求太多，从哪里下手做架构设计？</p>
</li>
<li>
<p>A: 熟悉和理解需求，识别系统复杂性，针对复杂点做架构设计。</p>
</li>
<li>
<p>Q: 架构设计要考虑高性能、高可用、高扩展、时间紧任务重，可能完不成。</p>
</li>
<li>
<p>A: 架构设计并不是要面面俱到，关键是要识别出复杂点，有针对性地解决问题。</p>
</li>
<li>
<p>Q: A 公司的架构是 X，B 公司的架构师 Y，我们公司该用哪个呢？</p>
</li>
<li>
<p>A: 理解每个架构方案背后所要解决的复杂点，再根据自己业务的实际复杂点，参考相似的方案。</p>
</li>
<li>
<p>Q: 我们的系统要做到 TPS XX 万。</p>
</li>
<li>
<p>A: 如果系统复杂度不在性能上，那么 TPS 做到 XX 万并没有用。</p>
</li>
<li>
<p>Q: 淘宝架构是这样，我们也要这样。</p>
</li>
<li>
<p>A: 淘宝的架构是为了解决它的业务复杂度而设计的，绝大多数普通公司业务的用户量和淘宝都是天差地别的。</p>
</li>
<li>
<p>Q: Docker 很流行，我们的架构也要用 Docker。</p>
</li>
<li>
<p>A: Docker 不是万能的，只是为了解决资源重用和动态分配而设计的，如果系统复杂度不在这里，就没有必要引入 Docker。</p>
</li>
</ul>
<h3 id="复杂度分析案例">复杂度分析案例</h3>
<p>设计一个大学的学生管理系统，基本功能包括登录、注册、成绩管理、课程管理等。</p>
<p>对这样一个系统进行架构设计时，首先要识别它的复杂度在哪里。</p>
<p>性能：一个大学的学生大约有 1~2 万人，学生管理系统访问频率不高，平均每天每个学生的访问次数可能不到 1 次，性能这部分不复杂。
存储用 MySQL 完全够了，缓存都可以不用，Web 服务器用 Nginx 也是绰绰有余。</p>
<p>可扩展性：学生管理系统的功能比较稳定，可扩展的空间并不大，可扩展性也不复杂。</p>
<p>高可用：学生管理系统即使宕机 2 小时，对学生管理工作的影响也不大，可以不做负载均衡，更不用说异地多活。
但是如果学生数据全部丢失，修复起来就非常麻烦，只能人工逐条修复，不可接受，所以存储要做到高可靠。
这里有些负责，要考虑多种异常情况：针对机器故障要设计 MySQL 同机房主备方案；针对机房故障要设计 MySQL 跨机房同步方案。</p>
<p>安全性：学生管理系统存储的学生信息有一定的隐私性，但没有达到金融级别，也不包含强隐私（个人照片、情感等）信息。
所以安全性方面做 3 件事就能基本满足要求：Nginx 做 ACL 控制，用户账号密码管理，数据库访问权限控制。</p>
<p>成本：系统很简单，几台服务器就能搞定，对大学来说不是问题，不用太关注。</p>
<p>综上可知，该方案的主要复杂性体现在存储可靠性上，要能保证出现异常时，不要丢失所有数据即可（丢失几十个学生信息问题不大）。</p>
<h3 id="todo-1">TODO</h3>
<p>分析一下公司业务的复杂度。</p>
<hr>
<h2 id="04--复杂度来源高性能">04 | 复杂度来源：高性能</h2>
<ul>
<li>课程链接：<a href="https://time.geekbang.org/column/article/6605">https://time.geekbang.org/column/article/6605</a></li>
</ul>
<p>软件系统中高性能带来的复杂度主要体现在两方面：</p>
<ol>
<li>单台计算机内部为了高性能带来的复杂度</li>
<li>多台计算机集群为了高性能带来的复杂度</li>
</ol>
<h3 id="单机复杂度">单机复杂度</h3>
<p>最关键的地方：用于发挥硬件性能、提供软件系统运行环境的操作系统，它的复杂度直接决定了软件系统的复杂度。</p>
<p>最早期的计算机：只能输入、计算、输出，大量时间在等待用户输入指令，效率很低</p>
<p>→ 批处理系统：预先写好指令清单，交给计算机去执行。但一次只能执行一个任务，如果是耗时的 I/O 任务，CPU 又空闲了，其实可以做其他计算</p>
<p>→ 进程：一个任务一个进程，每个任务有独立内存空间，进程间互不相关，由操作系统调度进程。多进程并行运行通过 CPU 分时实现，虽然本质上还是串行，但 CPU 速度很快，用户角度就是多进程并行处理。</p>
<p>→ 进程间通信：两个任务之间如果能在运行过程中通信，任务设计就能更加灵活高效。因此有了管道、消息队列、信号量、共享存储等。</p>
<p>→ 线程：单个进程内部只能串行处理，而实际上进程内的很多子任务没有时间顺序要求，并行处理会更快，从而有了线程：进程内部的子任务，共享同一份进程数据。为保证数据正确，又发明了互斥锁机制。</p>
<p>有了多线程后，操作系统调度的最小单位是线程，分配资源的最小单位是进程。</p>
<p>操作系统发展到现在，如果要完成一个高性能软件系统，需要考虑多进程、多线程、进程间通信、多线程并发等技术点，并不是最新就最好，也不是非此即彼。
做架构设计时，要花很大精力结合业务进行分析、判断、选择，组合，这个过程很复杂。
比如 Nginx 可以多进程也可以多线程，JBoss 用的多线程；Redis 用的单进程，Memcache 用的多线程。这些系统都实现了高性能，但内部实现的差异却很大。</p>
<h3 id="集群复杂度">集群复杂度</h3>
<p>支付宝和微信的支付和红包这种业务，单机肯定扛不住，必须用机器集群实现高性能，在支付宝和微信，这种业务系统的机器数量都是万台级别的。</p>
<p>通过大量机器提升性能，并不是简简单单地加机器就可以。要让多台机器配合起来实现高性能，是一个复杂的任务。</p>
<h4 id="任务分配">任务分配</h4>
<p>任务分配：在每台机器都可以处理完整的业务任务的前提下，将同类任务分配到不同的机器上执行。</p>
<ul>
<li>最初的 1 台任务服务器扩充至 2 台后，还需要增加 1 台任务分配器，选择合适的任务分配器需要综合考虑性能、成本、可维护性、可用性等各方面因素。</li>
<li>任务分配器和各台任务服务器之间有连接和交互，需要选择合适的连接方式，并且对连接进行管理，包括连接建立、连接检测、连接中断后的处理等。</li>
<li>任务分配器需要有分配算法，包括轮询算法、按权重分配、按负载分配等。如果按负载分配，业务服务器还要能够上报自己的状态给任务分配器。</li>
</ul>
<p>假设单台业务服务器每秒能够处理 5000 次业务请求，如果只是最简单地增加 1 台业务机器，那么这个架构理论上能够支撑 10000 次请求，实际上的性能一般按照 8 折计算，大约是 8000 次左右，这还是比较好的情况下，实际可能会更差。</p>
<p>假设性能要求继续提高到每秒 10 万次，并不是加到 25 台机器就可以的。因为这时候任务分配器的性能又会成为瓶颈，也需要扩展为多台。</p>
<p>这个时候架构就更加复杂了：</p>
<ul>
<li>需要先将用户分配到不同的任务分配器上，常见方法包括 DNS 轮询、智能 DNS、CDN、GSLB 设备等。</li>
<li>任务分配器和业务服务器的连接，从简单的“1对多”，变成了“多对多”的网状结构。</li>
<li>机器数量从 3 台增加到 30 台（5 台任务分配器，25 台业务服务器），状态管理、故障处理复杂度也大大增加。</li>
</ul>
<p>上面的例子都是以业务处理为例，实际上“任务”涵盖的范围很广，可以指完整的业务处理，也可以单指某个具体的任务，比如存储、运算、缓存都可以作为一项任务，所以存储系统、运算系统、缓存系统也都可以按照任务分配的方式来搭建架构。另外，任务分配器也不一定只能是物理机器或者是一个独立运行的程序，也可以是嵌入在其他程序中的算法，比如 Memcache 的集群架构。</p>
<h4 id="任务分解">任务分解</h4>
<p>任务分配可以突破单台机器处理性能的瓶颈，通过增加机器来满足业务的性能需求。但如果业务本身越来越复杂，单纯通过任务分配的方式来扩展性能的收益会越来越低。</p>
<p>比如业务简单的时候，从 1 台机器扩展到 10 台机器，性能可以提升 8 倍；但如果业务十分复杂的时候，1 台机器扩展到 10 台机器，性能可能只能提升 5 倍。因为复杂的业务让单台机器的处理性能越来越低，为了继续提升性能，就需要采取第二种方式：<strong>任务分解</strong>。</p>
<p>以微信后台架构为例，可以从逻辑上将各个子业务进行拆分，包括接入、注册登录、消息、LBS、摇一摇、漂流瓶、其他业务（聊天、视频、朋友圈等）。</p>
<p>进行这样的任务分解，可以把原来大一统但复杂的业务系统，拆分成小而简单、但需要多个系统互相配合的业务系统。</p>
<p>从业务的角度来看，任务分解既不会减少功能，也不会减少代码量（其实往往还会增加代码量，因为要从代码内部调用改为通过服务器之间的接口调用），它提升性能主要通过以下几方面实现：</p>
<p><strong>简单系统更容易做到高性能</strong>。</p>
<p>系统功能越简单，影响性能的点越少，就越容易做有针对性的优化。很复杂的系统难以找到关键性能点，而且修改起来也很难，因为可能将 A 关键性能点提升了却又无意中将 B 点性能降低，导致系统整体性能下降。</p>
<p><strong>可针对单个任务进行扩展</strong>。</p>
<p>各个逻辑任务分解到独立的子系统后，更容易发现整个系统的性能瓶颈，并且只需针对有瓶颈的子系统进行改进，不需要改动整个系统，风险小很多。比如微信用户增长太快时，注册登录子系统出现性能瓶颈，只需要优化该子系统性能即可，可以是代码优化，也可以是简单粗暴地加机器，其他子系统完全不需要改动。</p>
<p>但子系统并不是划分得越细越好，因为还需要考虑到系统间调用。如果系统拆分得太细，系统间调用次数会呈指数级上升，而系统间调用通道目前都是通过网络传输的方式，性能远比系统内的函数调用低得多。</p>
<p>比如把系统拆分为 2 个子系统的时候，用户访问需要 1 次系统间的请求和 1 次响应；如果拆分为 100 个子系统，系统间的请求和相应次数变成了 99 次。</p>
<p>假设系统间采用 IP 网络连接，理想情况下 1 次请求 + 响应在网络上耗时 1ms，业务处理本身耗时 50ms。同时假设系统拆分对单个业务请求的性能无影响，那么系统拆分为 2 个子系统的时候，处理一次用户访问耗时为 51ms，看着还好；但拆分为 100 个子系统的时候，处理一次用户访问耗时就达到了 149ms。</p>
<p>虽然系统拆分可能在某种程度上提升业务处理性能，但这个提升也是有限的，不太可能从 50ms 优化到 1ms，因为最终决定业务处理性能的还是业务逻辑本身。如果业务逻辑本身没有大的变化，理论性能是有上限的，系统拆分只能让性能逼近极限，但无法突破极限。所以任务分解带来的性能收益是有一个度的，架构设计的一个关键就是要把握好这个度。</p>
<hr>
<h2 id="16--高性能nosql">16 | 高性能NoSQL</h2>
<ul>
<li>课程链接：<a href="https://time.geekbang.org/column/article/8377">https://time.geekbang.org/column/article/8377</a></li>
</ul>
<p>专栏作者在评论区提到的他写的文章，质量很高：<a href="https://www.infoq.cn/article/talk-about-technology">当我们聊技术实力的时候，我们到底在聊什么</a></p>
</div>
                    <div class="post_footer">
                        
                    </div>
                </div>
                
                
                
<div class="doc_comments">
    <div class="comments_block_title">发表评论</div>
    <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="https://www.hewei.in/css/comments.css" />
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: '6kGh7JpRLb89n7mDsx4LmntN-gzGzoHsz',
        appKey: 'kWKa5LtKrMR1sMPfRl5Wzx4r',
        placeholder: '',
        visitor: 'true',
    })
</script>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span></span>
    </div>
</footer>
    <script src="https://www.hewei.in/js/jquery-3.5.1.min.js"></script>
<link href="https://www.hewei.in/css/fancybox.min.css" rel="stylesheet">
<script src="https://www.hewei.in/js/fancybox.min.js"></script>
<script src="https://www.hewei.in/js/zozo.js"></script>




</body>

</html>