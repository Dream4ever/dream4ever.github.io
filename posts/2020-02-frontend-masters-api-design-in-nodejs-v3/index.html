<!DOCTYPE html>
<html lang="en-us" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="何伟" />
	
	
	
	<title>API Design in Node.js, v3 课程学习笔记 ｜ 岁月留痕</title>
	
    
    
    <meta name="description" content="之前在研究该如何更好地设计 Node.js API 时，在网上找到了 Frontend Masters 的《API Design in Node.js, v3》这门课，当时大致看了一下 GitHub 上对应的代码，觉得这门课程设计得挺不错，于是买了一个月的 Frontend Masters 会员，把这门课程认真学了一遍，并且把关键部分都做了笔记，具体内容见文章正文。
课程地址 API Design in Node.js, v3
环境配置 在 macOS 上安装 MongoDB 参考 Install MongoDB Community Edition on macOS。
简而言之，就是通过 Homebrew 安装 MongoDB，并按照官方建议，用 brew 将 MongoDB 以服务的方式运行在后台。
注意事项 Yarn 及 NPM 因为课程已经是一年多以前的了，项目中的依赖库版本也没怎么更新，所以如果遇到用 Yarn 或 NPM 安装依赖库会失败的情况，比如 bcrypt 这个库，那么可以先删除对应的库，然后重新安装，这样会安装最新版，通常都能成功。
" />
    

    

	
    
    <link rel="shortcut icon" href="https://www.hewei.in/images/favicon.ico" />

    <link rel="stylesheet" type="text/css" media="screen" href="https://www.hewei.in/css/normalize.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://www.hewei.in/css/zozo.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css" />
    <link rel="stylesheet" type="text/css" media="screen" href="https://www.hewei.in/css/highlight.css" />

    
    
</head>

<body>
    <div class="main animate__animated animate__fadeInDown">
        <div class="nav_container animated fadeInDown">
    <div class="site_nav" id="site_nav">
        <ul>
            
            <li>
                <a href="/">首页</a>
            </li>
            
            <li>
                <a href="/posts/">归档</a>
            </li>
            
            <li>
                <a href="/tags/">标签</a>
            </li>
            
            <li>
                <a href="/about/">我</a>
            </li>
            
        </ul>
    </div>
    <div class="menu_icon">
        <a id="menu_icon"><i class="ri-menu-line"></i></a>
    </div>
</div>
        <div class="header animated fadeInDown">
    <div class="site_title_container">
        <div class="site_title">
            <h1>
                <a href="https://www.hewei.in/">
                    <span>岁月留痕</span>
                </a>
            </h1>
        </div>
        <div class="description">
            <p class="sub_title"></p>
            <div class="my_socials">
                
                
                <a href="https://github.com/Dream4ever" title="github" target="_blank"><i class="ri-github-fill"></i></a>
                
                
                <a href="https://www.hewei.in/index.xml" type="application/rss+xml" title="rss" target="_blank"><i
                        class="ri-rss-fill"></i></a>
            </div>
        </div>
    </div>
</div>
        <div class="content">
            <div class="post_page">
                <div class="post animate__animated animate__fadeInDown">
                    <div class="post_title post_detail_title">
                        <h2><a href='/posts/2020-02-frontend-masters-api-design-in-nodejs-v3/'>API Design in Node.js, v3 课程学习笔记</a></h2>
                        <span class="date">2020.02.04</span>
                    </div>
                    <div class="post_content markdown"><p>之前在研究该如何更好地设计 Node.js API 时，在网上找到了 Frontend Masters 的《API Design in Node.js, v3》这门课，当时大致看了一下 GitHub 上对应的代码，觉得这门课程设计得挺不错，于是买了一个月的 Frontend Masters 会员，把这门课程认真学了一遍，并且把关键部分都做了笔记，具体内容见文章正文。</p>
<h2 id="课程地址">课程地址</h2>
<p><a href="https://frontendmasters.com/courses/api-design-nodejs-v3/">API Design in Node.js, v3</a></p>
<h2 id="环境配置">环境配置</h2>
<h3 id="在-macos-上安装-mongodb">在 macOS 上安装 MongoDB</h3>
<p>参考 <a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/">Install MongoDB Community Edition on macOS</a>。</p>
<p>简而言之，就是通过 Homebrew 安装 MongoDB，并按照官方建议，用 brew 将 MongoDB 以服务的方式运行在后台。</p>
<h2 id="注意事项">注意事项</h2>
<h3 id="yarn-及-npm">Yarn 及 NPM</h3>
<p>因为课程已经是一年多以前的了，项目中的依赖库版本也没怎么更新，所以如果遇到用 Yarn 或 NPM 安装依赖库会失败的情况，比如 <code>bcrypt</code> 这个库，那么可以先删除对应的库，然后重新安装，这样会安装最新版，通常都能成功。</p>
<h2 id="express-中间件">Express 中间件</h2>
<h3 id="适用场景">适用场景</h3>
<p>可对传入的请求进行验证、转换、追踪、错误处理等各种常用功能。</p>
<h3 id="定义">定义</h3>
<p>下面的代码展示了一个中间件的定义和使用。</p>
<p>// TODO</p>
<p>为什么 app.use(log()) 这种调用格式会出错？</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">log</span> <span class="o">=</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;logging&#39;</span><span class="p">)</span>
  <span class="nx">next</span><span class="p">()</span>
<span class="p">}</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">log</span><span class="p">)</span>
</code></pre></div><h3 id="next">next</h3>
<p>在定义中间件的代码里，next() 的作用，就是让当前中间件处理完请求之后，将请求继续往下传下去。而不是像控制器那样，用 res.send() 或 res.end() 作出响应并结束请求。</p>
<p>在 Express 中，就是 next() 将中间件们串起来的，这样才能依次让各个中间件处理请求。</p>
<h3 id="使用">使用</h3>
<p>下面几种都是中间件的使用方式。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 1. 处理所有请求
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">cors</span><span class="p">())</span>

<span class="c1">// 2. 只处理特定路由
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="nx">log</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">})</span>

<span class="c1">// 3. 只对特定路由调用若干中间件
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">[</span><span class="nx">log1</span><span class="p">,</span> <span class="nx">log2</span><span class="p">,</span> <span class="nx">log3</span><span class="p">],</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">})</span>
</code></pre></div><h3 id="作用">作用</h3>
<p>对传入请求，以确定的顺序执行一系列处理函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 下面的中间件将严格按调用顺序执行
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">cors</span><span class="p">())</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">json</span><span class="p">())</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">urlencoded</span><span class="p">({</span> <span class="nx">extended</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}))</span>
<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="nx">morgan</span><span class="p">(</span><span class="s1">&#39;dev&#39;</span><span class="p">))</span>
</code></pre></div><h3 id="中间件互相通信">中间件互相通信</h3>
<p>如何在一个中间件中，将错误，或者普通的消息传到下一个中间件，或者控制器中？</p>
<p>很简单，将数据附加到传入请求（request ）上即可。这样不管是在其后的中间件，或者控制器中，都可以调用所附加的数据。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">log</span> <span class="o">=</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;logging&#39;</span><span class="p">)</span>
  <span class="nx">req</span><span class="p">.</span><span class="nx">myData</span> <span class="o">=</span> <span class="s1">&#39;hahahaha&#39;</span>
  <span class="nx">next</span><span class="p">()</span>
<span class="p">}</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="nx">log</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">({</span> <span class="nx">message</span><span class="o">:</span> <span class="nx">req</span><span class="p">.</span><span class="nx">myData</span> <span class="p">})</span>
<span class="p">})</span>
</code></pre></div><h3 id="错误处理">错误处理</h3>
<p>如果往中间件里的 next() 函数传入了参数，则参数会被当做错误进行处理。比如一个验证请求的中间件，发现请求不合法时，就可以向 next() 传入参数，然后在另一个专门处理错误的中间件中进行处理。</p>
<p>// TODO</p>
<p>如果在中间件的 next() 函数之前抛出错误，那么调用了该中间件的控制器，在满足错误抛出条件的情况下，控制器里的代码不会被执行。</p>
<p>但是，即使改为在 next() 函数里抛出错误，调用了该中间件的控制器，在满足错误抛出条件的情况下，控制器里的代码依然不会被执行。那两者有什么区别呢？区别只是在于，next() 中抛出的错误，能够被再之后的中间件接住并处理？</p>
<h3 id="中间件和控制器">中间件和控制器</h3>
<p>虽然中间件可以像控制器一样对请求作出响应，但不建议这么做。</p>
<p>中间件用于将数据进行处理之后，传给后续的中间件或路由进行下一步处理。而控制器则用于对数据进行处理，并将处理后的结果返回给 API 调用者。</p>
<p>可以将控制器理解为请求栈中，最终的那个中间件。</p>
<h2 id="express-路由">Express 路由</h2>
<h3 id="匹配模式">匹配模式</h3>
<p>下面是 Express 中的四种路由匹配模式，在编写 REST API 时，前两种最为常用。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 严格匹配
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/data&#39;</span><span class="p">)</span>
<span class="c1">// 参数匹配
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/:id&#39;</span><span class="p">)</span>
<span class="c1">// 正则匹配
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;^(me)&#39;</span><span class="p">)</span>
<span class="c1">// glob匹配
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/user/*&#39;</span><span class="p">)</span>
</code></pre></div><h3 id="rest-api">REST API</h3>
<p>HTTP 方法和具体的路由结合起来，就是 REST API。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// CRUD
</span><span class="c1"></span>
<span class="c1">// Create → put
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/data&#39;</span><span class="p">)</span>
<span class="c1">// Read → get
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/data&#39;</span><span class="p">)</span>
<span class="c1">// Update → put
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="s1">&#39;/data&#39;</span><span class="p">)</span>
<span class="c1">// Delete → delete
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s1">&#39;/delete&#39;</span><span class="p">)</span>
</code></pre></div><h3 id="顺序">顺序</h3>
<p>如果同一个路由路径定义了两次，那么会按照定义的先后次序执行。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// 执行完第一条匹配到的路由，返回 { data: 1 }
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">({</span> <span class="nx">data</span><span class="o">:</span> <span class="mi">1</span> <span class="p">})</span>
<span class="p">})</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">({</span> <span class="nx">data</span><span class="o">:</span> <span class="mi">2</span> <span class="p">})</span>
<span class="p">})</span>

<span class="c1">// 依次执行两条路由，返回 { data: 2 }
</span><span class="c1"></span><span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">next</span><span class="p">()</span>
<span class="p">})</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">({</span> <span class="nx">data</span><span class="o">:</span> <span class="mi">2</span> <span class="p">})</span>
<span class="p">})</span>
</code></pre></div><h3 id="router-与子-routes">Router 与子 routes</h3>
<p>不同的 API 路径会需要不同的路由规则，比如一类 API 路径是用于返回 JSON 信息的，另一类 API 路径是用于调用机器学习接口的，那么这两类 API 可能就需要不同的验证规则，这个时候，为两类 API 设置各自的 router，就能实现这个需求了。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// Router 用法示例 /api/me
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">router</span> <span class="o">=</span> <span class="nx">express</span><span class="p">.</span><span class="nx">Router</span><span class="p">()</span>

<span class="nx">router</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;/me&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">({</span> <span class="nx">me</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span> <span class="p">})</span>
<span class="p">})</span>

<span class="nx">app</span><span class="p">.</span><span class="nx">use</span><span class="p">(</span><span class="s1">&#39;/api&#39;</span><span class="p">,</span> <span class="nx">router</span><span class="p">)</span>
</code></pre></div><h3 id="router-verb-methods">Router Verb Methods</h3>
<p>对于 REST API 来说，CRUD 可以统一抽象为以下五种操作：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">routes</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s1">&#39;get /cat&#39;</span><span class="p">,</span>
  <span class="s1">&#39;get /cat/:id&#39;</span><span class="p">,</span>
  <span class="s1">&#39;post /cat&#39;</span><span class="p">,</span>
  <span class="s1">&#39;put /cat/:id&#39;</span><span class="p">,</span>
  <span class="s1">&#39;delete /cat/:id&#39;</span>
<span class="p">]</span>
</code></pre></div><p>虽然说这五种操作的 HTTP 方法各不相同，但是在路由的路径层面，其实只有两种。那有没有方法能够简化路由代码的编写呢？当然有，下面的代码就是：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="nx">router</span><span class="p">.</span><span class="nx">route</span><span class="p">(</span><span class="s1">&#39;/cat&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">get</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">post</span><span class="p">()</span>

<span class="nx">router</span><span class="p">.</span><span class="nx">route</span><span class="p">(</span><span class="s1">&#39;/cat/:id&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">get</span><span class="p">()</span>
  <span class="p">.</span><span class="nx">put</span><span class="p">()</span>
  <span class="p">.</span><span class="k">delete</span><span class="p">()</span>
</code></pre></div><h2 id="express-控制器">Express 控制器</h2>
<h3 id="与中间件的区别">与中间件的区别</h3>
<p>前面讲过两者之间的区别，而控制器唯一表现得像中间件的时候，就是它需要将捕捉到的错误传给专门处理错误的中间件的时候，这时需要调用 next() 将错误传下去才行。</p>
<p>除此之外，控制器都是请求栈的终点，在控制器中完成最后的处理之后，就结束请求，返回调用端所需的内容。</p>
<h3 id="编码规范">编码规范</h3>
<p>通常在控制器中设置 HTTP 响应的状态码，并填入所需返回的内容，然后就向 API 的调用端发回响应。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">send</span><span class="p">({</span> <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span> <span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p>不建议在响应已经发出之后再做操作。一个好的编码习惯，就是在返回响应的语句前面显示加上 <code>return</code>，这样开发者就能意识到响应已经结束，不要再做后续操作了。</p>
<p>当然了，也会有极其罕见的例外情况，比如 Stripe 这类支付 API，需要优先响应用户的请求，然后可能需要再做后续操作，不过这种情况遇到了再额外讨论。</p>
<p>另外也不建议在返回响应的语句后面再调用 <code>next()</code>，同样无法保证代码不会出问题。</p>
<h3 id="rest-api-控制器的通用化">REST API 控制器的通用化</h3>
<p>因为 REST API 将所有内容都视为“资源”，那么对于一般的资源来说，所需进行的操作都是相同的：CRUD。比如在这门课程中所示范的 TO-DO APP，对于待办事项列表（list），及每个列表中的待办事项（item），都会有这几项操作：getMany，getOne，createOne，updateOne，removeOne。由于这几项操作对各类资源其实是相同的，那么就可以为每种操作只定义一个通用的控制器，然后在各类资源中均调用这个控制器即可，这样就提高了代码的复用性。</p>
<h3 id="简单示例">简单示例</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// src/resources/item/item.controllers.js
</span><span class="c1"></span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">Item</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./item.model&#39;</span>
<span class="kr">import</span> <span class="nx">mongoose</span> <span class="nx">from</span> <span class="s1">&#39;mongoose&#39;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">connect</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;../../utils/db&#39;</span>

<span class="kr">const</span> <span class="nx">run</span> <span class="o">=</span> <span class="kr">async</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">await</span> <span class="nx">connect</span><span class="p">(</span><span class="s1">&#39;mongodb://localhost:27017/api-test&#39;</span><span class="p">)</span>
  
  <span class="kr">const</span> <span class="nx">item</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">Item</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Clean up&#39;</span><span class="p">,</span>
    <span class="nx">createdBy</span><span class="o">:</span> <span class="nx">mongoose</span><span class="p">.</span><span class="nx">Types</span><span class="p">.</span><span class="nx">ObjectId</span><span class="p">(),</span> <span class="c1">// 创建一个 fake ObjectId
</span><span class="c1"></span>    <span class="nx">list</span><span class="o">:</span> <span class="nx">mongoose</span><span class="p">.</span><span class="nx">Types</span><span class="p">.</span><span class="nx">ObjectId</span><span class="p">()</span> <span class="c1">// 创建一个 fake ObjectId
</span><span class="c1"></span>  <span class="p">})</span>
  
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">run</span><span class="p">()</span>
</code></pre></div><p>执行 <code>npm run build</code> 编译代码，然后执行 <code>node dist/resources/item/item.controllers.js</code> 运行上面的代码，就会在终端得到如下结果，说明创建文档的代码执行成功了。</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash"><span class="o">{</span>
  status: <span class="s1">&#39;active&#39;</span>,
  _id: 5e258de33d0523c9503570a0,
  name: <span class="s1">&#39;Clean up&#39;</span>,
  createdBy: 5e258de33d0523c95035709e,
  list: 5e258de33d0523c95035709f,
  createdAt: 2020-01-20T11:24:19.069Z,
  updatedAt: 2020-01-20T11:24:19.069Z,
  __v: <span class="m">0</span>
<span class="o">}</span>
</code></pre></div><h3 id="crud">CRUD</h3>
<p>Mongoose API 与 CRUD 对应关系如下：</p>
<ul>
<li>C - <code>Model.create()</code>, <code>new Model()</code></li>
<li>R - <code>Model.find()</code>, <code>Model.findOne()</code>, <code>Model.findById()</code></li>
<li>U - <code>model.update()</code>, <code>Model.findByIdAndUpdate()</code>, <code>Model.findOneAndUpdate()</code></li>
<li>D - <code>model.remove()</code>, <code>Model.findByIdAndRemove()</code>, <code>Model.findOneAndRemove()</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// Create One
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">item</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">Item</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span> <span class="p">...</span> <span class="p">})</span>

<span class="c1">// Read One
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kr">await</span> <span class="nx">Item</span><span class="p">.</span><span class="nx">findById</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">_id</span><span class="p">).</span><span class="nx">exec</span><span class="p">())</span>

<span class="c1">// Read Many
</span><span class="c1"></span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kr">await</span> <span class="nx">Item</span><span class="p">.</span><span class="nx">find</span><span class="p">().</span><span class="nx">exec</span><span class="p">())</span>

<span class="c1">// Update One
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">updated</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">Item</span><span class="p">.</span><span class="nx">findByIdAndUpdate</span><span class="p">(</span> <span class="nx">item</span><span class="p">.</span><span class="nx">_id</span><span class="p">,</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;eat&#39;</span> <span class="p">},</span> <span class="p">{</span> <span class="k">new</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}).</span><span class="nx">exec</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">updated</span><span class="p">)</span>

<span class="c1">// Remove One
</span><span class="c1"></span><span class="kr">const</span> <span class="nx">removed</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">Item</span><span class="p">.</span><span class="nx">findByIdAndRemove</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">_id</span><span class="p">).</span><span class="nx">exec</span><span class="p">()</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">removed</span><span class="p">)</span>
</code></pre></div><h3 id="面向测试编写-crud-controllers">“面向测试”编写 CRUD Controllers</h3>
<p>说明：</p>
<ul>
<li>CRUD Controllers 定义文件：<code>src/utils/crud.js</code></li>
<li>测试用例文件：<code>src/utils/__tests__/crud.spec.js</code></li>
</ul>
<p>在测试用例 <code>crud.spec.js</code> 中，定义了上一小节五种 CRUD 所需满足的条件。</p>
<p>以 <code>getOne</code> 为例，在其 <code>describe</code> 函数中，定义了需测试的两种情况，一种是 <code>test('finds by authenticated user and id')</code>，另一种是 <code>test('404 if no doc was found')</code>，也就是 <code>getOne</code> 成功和失败时所应满足的不同条件。先看前一种，即 <code>getOne</code> 成功时所应满足的条件。</p>
<p>在 <code>test('finds by authenticated user and id')</code> 函数中，有如下代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">req</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">params</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">id</span><span class="o">:</span> <span class="nx">list</span><span class="p">.</span><span class="nx">_id</span>
  <span class="p">},</span>
  <span class="nx">user</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">_id</span><span class="o">:</span> <span class="nx">user</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>也就是说在传入请求（request）中，<code>params</code> 参数中会传入 <code>id</code> 这个字段，而 <code>user</code> 参数中会传入 <code>_id</code> 这个字段。</p>
<p>那么在 <code>src/utils/crud.js</code> 文件中，就需要把这两个字段用起来：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">getOne</span> <span class="o">=</span> <span class="nx">model</span> <span class="p">=&gt;</span> <span class="kr">async</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">id</span>
  <span class="kr">const</span> <span class="nx">userId</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">_id</span>
<span class="p">}</span>
</code></pre></div><p>而在 <code>test()</code> 函数的后半部分，又有如下代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">status</span><span class="p">(</span><span class="nx">status</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">status</span><span class="p">).</span><span class="nx">toBe</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">this</span>
  <span class="p">},</span>
  <span class="nx">json</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">_id</span><span class="p">.</span><span class="nx">toString</span><span class="p">()).</span><span class="nx">toBe</span><span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">_id</span><span class="p">.</span><span class="nx">toString</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>这段代码要求被测试代码所返回的请求，其状态码应当为 <code>200</code>，并且所返回的 JSON 中，文档的属性名要定义为 <code>data</code>。</p>
<p>那么在 <code>src/utils/crud.js</code> 文件中，就需要编写如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">model</span><span class="p">.</span><span class="nx">findOne</span><span class="p">({</span> <span class="nx">_id</span><span class="o">:</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">createdBy</span><span class="o">:</span> <span class="nx">userId</span> <span class="p">}).</span><span class="nx">exec</span><span class="p">()</span>

<span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nx">status</span><span class="p">(</span><span class="mi">200</span><span class="p">).</span><span class="nx">json</span><span class="p">({</span> <span class="nx">data</span><span class="o">:</span> <span class="nx">doc</span> <span class="p">})</span>
</code></pre></div><p>上面代码中，第一行的查询语句不需多说，后面的 <code>status(200)</code> 用于设置 HTTP 响应状态码。这里要说明一下，如果返回数据用的是 <code>res.send()</code>，那么 HTTP 响应状态码默认就是 <code>200</code>。但这次的测试用例中，要求返回的是 JSON，没有这个默认设置，所以需要主动设置一下。</p>
<p>而后面的 <code>.json({ data: doc })</code>，则是将查询到的文档赋给所需返回对象的 <code>data</code> 字段值，并用 <code>json()</code> 函数处理成 JSON，然后返回。</p>
<p>这里有一点要注意：将数据用对象的一个字段名进行命名是一种好习惯，以便于调用端了解 API 所返回的究竟是什么内容，是数据（data）还是错误（error），或者是别的什么信息。如果直接返回查询到的数据，比如 <code>res.send(doc)</code>，前端还需要进行很多额外的判断，比如区分这是查询到的数据还是报错还是别的什么，就会增加很多工作量，也容易出错。</p>
<h2 id="auth">Auth</h2>
<h3 id="概念辨析">概念辨析</h3>
<ul>
<li>Authentication: 身份验证/鉴权，用于判断传入的请求是否能被放行，比如用户相关的 API 要求调用端必须附带用户信息。</li>
<li>Authorization: 授权，用于判断传入的请求是否有权限执行特定操作，比如用户相关的 API 禁止普通用户删除其它用户。</li>
<li>Identification: 身份识别，用于判断是谁传入的请求，包括物理设备，运行环境，UserAgent 等等。</li>
</ul>
<h3 id="jwt-身份验证">JWT 身份验证</h3>
<ul>
<li>JWT 可以实现<strong>无状态</strong>的用户身份验证。而 session 和 cookie 实现的是<strong>有状态</strong>的用户身份验证，需要将 session 或 cookie 存储在服务端。</li>
<li>JWT 身份验证是一种 bearer token stratagy，有了 bearer token，服务端就可以验证客户端的请求 header 中的 token。和 API Key 一样，JWT 也是诸多 bearer 验证方法中的一种。</li>
<li>要创建 JWT，需要 API secret 以及 user object 之类的 payload。服务端分别对 secret 和 payload 进行 hash，然后再将两者结合，生成 JWT？其中前端传来的 payload，最好是能够识别用户身份的，比如用户的角色、ID 之类的数据。</li>
<li>JWT 是在服务端创建 token，并将其发给验证过的客户端的。之后客户端每次向服务端发送请求时，都要带上这个 token，后端就可以先 authentication，对请求进行鉴权；然后再 identification，识别用户的身份；最后再由 controller 决定是否要 authorization，即授权。</li>
<li>服务端每次接收到请求时，先判断 token 是否是用自己的 secret 生成的，如果是，那么就能够拿到其中的 payload，即用户数据，然后就可以在后端的各个环节中使用了。</li>
</ul>
<h2 id="接口测试">接口测试</h2>
<h3 id="测试路由">测试路由</h3>
<p>router 的测试代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="c1">// src/resources/item/__tests__/item.router.spec.js
</span><span class="c1"></span>
<span class="kr">import</span> <span class="nx">router</span> <span class="nx">from</span> <span class="s1">&#39;../item.router&#39;</span>

<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;item router&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">test</span><span class="p">(</span><span class="s1">&#39;has crud routes&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">routes</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;get&#39;</span> <span class="p">},</span>
      <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/:id&#39;</span><span class="p">,</span> <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;get&#39;</span> <span class="p">},</span>
      <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/:id&#39;</span><span class="p">,</span> <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;delete&#39;</span> <span class="p">},</span>
      <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/:id&#39;</span><span class="p">,</span> <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;put&#39;</span> <span class="p">},</span>
      <span class="p">{</span> <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;post&#39;</span> <span class="p">}</span>
    <span class="p">]</span>

    <span class="nx">routes</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">route</span> <span class="p">=&gt;</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">match</span> <span class="o">=</span> <span class="nx">router</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span>
        <span class="nx">s</span> <span class="p">=&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">route</span><span class="p">.</span><span class="nx">path</span> <span class="o">===</span> <span class="nx">route</span><span class="p">.</span><span class="nx">path</span> <span class="o">&amp;&amp;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">route</span><span class="p">.</span><span class="nx">methods</span><span class="p">[</span><span class="nx">route</span><span class="p">.</span><span class="nx">method</span><span class="p">]</span>
      <span class="p">)</span>
      <span class="nx">expect</span><span class="p">(</span><span class="nx">match</span><span class="p">).</span><span class="nx">toBeTruthy</span><span class="p">()</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div><p>router 的业务代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="p">{</span> <span class="nx">Router</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;express&#39;</span>

<span class="kr">const</span> <span class="nx">controller</span> <span class="o">=</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">send</span><span class="p">({</span> <span class="nx">message</span><span class="o">:</span> <span class="s1">&#39;hello&#39;</span> <span class="p">})</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">router</span> <span class="o">=</span> <span class="nx">Router</span><span class="p">()</span>

<span class="nx">router</span><span class="p">.</span><span class="nx">route</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span>

<span class="nx">router</span><span class="p">.</span><span class="nx">route</span><span class="p">(</span><span class="s1">&#39;/:id&#39;</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">put</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span>
  <span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">controller</span><span class="p">)</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">router</span>
</code></pre></div><p>测试和业务的代码分别按照上面的方式写，测试就可正常通过。</p>
<h2 id="mongodb--mongoose">MongoDB &amp; Mongoose</h2>
<h3 id="schema-与-modal">Schema 与 Modal</h3>
<p>Schema 和 Modal 的关系，是不是可以理解为 Class 和 Object 之间的关系？</p>
<p>Schema 决定了 Modal 有哪些字段，如何对 Modal 的字段进行验证、索引、hook（这个怎么翻译？）等等。</p>
<h3 id="实例">实例</h3>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">import</span> <span class="nx">mongoose</span> <span class="nx">from</span> <span class="s1">&#39;mongoose&#39;</span>

<span class="kr">const</span> <span class="nx">itemSchema</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">mongoose</span><span class="p">.</span><span class="nx">Schema</span><span class="p">(</span>
  <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span>
      <span class="nx">required</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 该字段不能为空
</span><span class="c1"></span>      <span class="nx">trim</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="c1">// 可删除首尾的空白字符
</span><span class="c1"></span>      <span class="nx">maxlength</span><span class="o">:</span> <span class="mi">50</span> <span class="c1">// 设置字段最大长度
</span><span class="c1"></span>    <span class="p">},</span>
    <span class="nx">status</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span>
      <span class="kr">enum</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;active&#39;</span><span class="p">,</span> <span class="s1">&#39;complete&#39;</span><span class="p">,</span> <span class="s1">&#39;pastdue&#39;</span><span class="p">],</span> <span class="c1">// 字段值从这几个中枚举
</span><span class="c1"></span>      <span class="k">default</span><span class="o">:</span> <span class="s1">&#39;active&#39;</span> <span class="c1">// 字段的默认值
</span><span class="c1"></span>    <span class="p">},</span>
    <span class="nx">due</span><span class="o">:</span> <span class="nb">Date</span><span class="p">,</span>
    <span class="nx">createdBy</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">type</span><span class="o">:</span> <span class="nx">mongoose</span><span class="p">.</span><span class="nx">Schema</span><span class="p">.</span><span class="nx">Types</span><span class="p">.</span><span class="nx">ObjectId</span><span class="p">,</span>
      <span class="nx">ref</span><span class="o">:</span> <span class="s1">&#39;user&#39;</span> <span class="c1">// TODO: 从 user 这个 Modal 中查找其 ObjectId 的值？
</span><span class="c1"></span>    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">{</span> <span class="nx">timestamps</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}</span>
<span class="p">)</span>

<span class="c1">// 下面的索引设置，规定了每个 list 中的 name 必须唯一
</span><span class="c1">// 如果交换 list 和 name 的顺序，则要求每个 name 中的 list 必须唯一
</span><span class="c1"></span><span class="nx">itemSchema</span><span class="p">.</span><span class="nx">index</span><span class="p">({</span> <span class="nx">list</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">name</span><span class="o">:</span> <span class="mi">1</span> <span class="p">},</span> <span class="p">{</span> <span class="nx">unique</span><span class="o">:</span> <span class="kc">true</span> <span class="p">})</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="nx">Item</span> <span class="o">=</span> <span class="nx">mongoose</span><span class="p">.</span><span class="nx">model</span><span class="p">(</span><span class="s1">&#39;item&#39;</span><span class="p">,</span> <span class="nx">itemSchema</span><span class="p">)</span>
</code></pre></div><h3 id="exec">exec</h3>
<p>在 Mongoose 中，查询语句之后如果不加上 <code>.exec()</code>，那么返回的是假的 Promise；加上 <code>.exec()</code> 之后，就相当于告诉 Mongoose，我的查询语句写完了，现在正式开始查询吧，这个时候得到的才是真正的 Promise。</p>
<div class="highlight"><pre class="chroma"><code class="language-js" data-lang="js"><span class="kr">const</span> <span class="nx">item</span> <span class="o">=</span> <span class="kr">await</span> <span class="nx">Item</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span> <span class="p">...</span> <span class="p">})</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kr">await</span> <span class="nx">Item</span><span class="p">.</span><span class="nx">findById</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">_id</span><span class="p">).</span><span class="nx">exec</span><span class="p">())</span>
</code></pre></div><p>参考资料：<a href="https://stackoverflow.com/questions/31549857/mongoose-what-does-the-exec-function-do">Mongoose - What does the exec function do?</a></p></div>
                    <div class="post_footer">
                        
                        <div class="meta">
                            <div class="info">
                                <span class="field tags">
                                    <i class="ri-stack-line"></i>
                                    
                                    <a href="https://www.hewei.in/tags/node.js/">Node.js</a>
                                    
                                    <a href="https://www.hewei.in/tags/system-design-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">System Design 系统设计</a>
                                    
                                </span>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                
                
<div class="doc_comments">
    <div class="comments_block_title">发表评论</div>
    <div id="vcomments"></div>
</div>

<link rel="stylesheet" href="https://www.hewei.in/css/comments.css" />
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>

<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: '6kGh7JpRLb89n7mDsx4LmntN-gzGzoHsz',
        appKey: 'kWKa5LtKrMR1sMPfRl5Wzx4r',
        placeholder: '',
        visitor: 'true',
    })
</script>
                
            </div>
        </div>
    </div>
    <a id="back_to_top" href="#" class="back_to_top"><i class="ri-arrow-up-s-line"></i></a>
    <footer class="footer">
    <div class="powered_by">
        <a href="https://varkai.com">Designed by VarKai,</a>
        <a href="http://www.gohugo.io/">Proudly published with Hugo</a>
    </div>

    <div class="footer_slogan">
        <span></span>
    </div>
</footer>
    <script src="https://www.hewei.in/js/jquery-3.5.1.min.js"></script>
<link href="https://www.hewei.in/css/fancybox.min.css" rel="stylesheet">
<script src="https://www.hewei.in/js/fancybox.min.js"></script>
<script src="https://www.hewei.in/js/zozo.js"></script>




</body>

</html>